# Для понимания описательных статистик и шкал было бы здорово попробовать написать 
# функцию хотя бы для некоторых из них. Чем мы и займёмся) В выполении заданий вам 
# помогут функции: sqrt(), ^ (обозначает возведение в степень. Например 2^2 = 4),
# table(), unique(), which.max(), which(). Постетировать каждую задачу можно на векторе x
# который вы можете видеть ниже. 

# Удачи вам!

x <- c(1, 2, 2, 3, 4, 3, 5, 1, 3, 7, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 5)

## Задание 1. (2 балла)
## Напишите ниже функцию, которая сможет посчитать стандартное отклонение. 
## Станартное отклонение считается путём извлечения квадратного корня из дисперсии. 

# Здесь и далее я считаю, что мы всё считаем для Генеральной совокупности

standard_deviation <- function(vec) {
  mean_val <- mean(vec)
  variance <- sum((vec - mean_val)^2) / (length(vec) - 1)  # Дисперсия
  sqrt(variance)  # Стандартное отклонение
}

# Тестирование функции
standard_deviation(x)
# 1.683251


## Задание 2 (2 балла)
## Напишите функцию, которая подсчитает z-оценку по шкале. Используйте функцию для 
## подсчёта стандартного отклонения из задания 1.

z_score <- function(vec) {
  mean_val <- mean(vec)
  sd_val <- standard_deviation(vec)
  (vec - mean_val) / sd_val
}

# Тестирование функции
z_score(x)
# (-1.5842361, -0.9901475, -0.9901475, ...)

## Задание 3 (2 балла)
## Напишите функцию подсчёта СТЕНа. Среднее 5.5, SD = 2. 

sten_score <- function(vec) {
  mean_val <- mean(vec)
  sd_val <- standard_deviation(vec)
  5.5 + 2 * (vec - mean_val) / sd_val
}

# Тестирование функции
sten_score(x)
# (2.331528, 3.519705, 3.519705, ...)


## Задание 4 (2 балла)
## В R есть много разных описательных статистик. Но, забавный факт, у вас может
## возникнуть проблема в том случае, если вам интересна мода. Как таковая, она 
## не появляется в описательных статистиках. Функция mode() занимается совсем не 
## тем, чем вы ожидали бы) Давайте исправим эту несправедливость и напишем недостающую
## Функцию. Напомню, что мода -- это самое частовстречаемое значение в векторе. 
## Вы можете задаться вопросом а как быть, если в векторе есть два одинаково часто
## встречаемых значений, то есть он 'мультимодальный'? А я отвечу -- представим, что
## такого не может быть) То есть достаточно написать функцию, которая найдёт одно 
## наиболее частое значение. На векторе x оно отлично сработает. 

calculate_mode <- function(vec) {
  freq_table <- table(vec)
  mode_value <- names(which.max(freq_table))
  as.numeric(mode_value)
}

# Тестирование функции
calculate_mode(x)
#5


## Задание 5 (2 балла)
## Напишите функцию, которая проверит является ли вектор мультимодальным, то есть
## потенциальных статистических мод больше 1. Ответом может являться, логические
## TRUE/FALSE или значения всех мод. Протестировать можно на векторах ниже. 

is_multimodal <- function(vec) {
  freq_table <- table(vec)
  max_count <- max(freq_table)
  modes <- as.numeric(names(freq_table[freq_table == max_count]))
  
  # Проверка, есть ли больше одной моды
  if (length(modes) > 1) {
    return(modes)  # Если мультимодальный, возвращаем все моды
  } else {
    return(FALSE)  # Если нет, возвращаем FALSE
  }
}

# Для x
is_multimodal(x)  
#  FALSE


y <- c(3,3,3,4,4,4,6)
is_multimodal(y)
# 3, 4


z <- c(2,2,2,2,7,6,5,3,5,5,7,5)
is_multimodal(z)
# 2, 5




